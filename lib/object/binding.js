// Generated by CoffeeScript 1.6.2
(function() {
  var BindableSetter, Binding, DeepPropertyWatcher, bindableSetter, options, toarray, type, utils,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BindableSetter = require("./setters/factory");

  bindableSetter = new BindableSetter();

  utils = require("../core/utils");

  options = require("../utils/options");

  toarray = require("toarray");

  DeepPropertyWatcher = require("./deepPropertyWatcher");

  type = require("type-component");

  /*
   Glues stuff together
  */


  module.exports = Binding = (function() {
    /*
    */
    Binding.prototype.__isBinding = true;

    /*
    */


    function Binding(_from, properties) {
      this._from = _from;
      this.now = __bind(this.now, this);
      this._properties = properties.split(/[,\s]+/g);
      this._limit = -1;
      this._delay = this._properties.length === 1 ? options.delay : options.computedDelay;
      this._setters = [];
      this._listeners = [];
      this._triggerCount = 0;
      this.map(function(value) {
        return value;
      });
      this._listen();
    }

    /*
    */


    Binding.prototype.now = function() {
      var hasChanged, listener, nvalues, setter, _i, _j, _len, _len1, _ref, _ref1;

      nvalues = [];
      _ref = this._listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        nvalues.push(listener.value());
      }
      hasChanged = false;
      _ref1 = this._setters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        setter = _ref1[_j];
        hasChanged = setter.change(nvalues) || hasChanged;
      }
      if (hasChanged && (~this._limit && ++this._triggerCount >= this._limit)) {
        this.dispose();
      }
      return this;
    };

    /*
     casts this binding as a collection binding
    */


    Binding.prototype.collection = function() {
      if (this._collectionBinding) {
        return this._collectionBinding;
      }
      this._collection = new Binding.Collection();
      this.to(this._collection.source);
      this.now();
      return this._collectionBinding = this._collection.bind().copyId(true);
    };

    /*
     binds to a target
    */


    Binding.prototype.to = function(target, property) {
      var setter;

      setter = bindableSetter.createSetter(this, target, property);
      if (setter) {
        this._setters.push(setter);
      }
      return this;
    };

    /*
     from property? create a binding going the other way. This is useful for classes. see class-test.js
    */


    Binding.prototype.from = function(from, property) {
      if (arguments.length === 1) {
        property = from;
        from = this._from;
      }
      return from.bind(property).to(this._from, this._properties);
    };

    /*
     maps the bound value
    */


    Binding.prototype.map = function(options) {
      if (!arguments.length) {
        return this._map;
      }
      this._map = utils.transformer(options);
      return this;
    };

    /*
     runs the binding just once
    */


    Binding.prototype.once = function() {
      return this.limit(1);
    };

    /*
     limits the number of times the binding can be called
    */


    Binding.prototype.limit = function(count) {
      this._limit = count;
      return this;
    };

    /*
     returns whether the binding is bound with ways
    */


    Binding.prototype.isBothWays = function() {
      return !!this._boundBothWays;
    };

    /*  
     makes the binding go both ways.
    */


    Binding.prototype.bothWays = function() {
      var setter, _i, _len, _ref;

      if (this._boundBothWays) {
        return this;
      }
      this._boundBothWays = true;
      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.bothWays();
      }
      return this;
    };

    /*
    */


    Binding.prototype.delay = function(value) {
      if (!arguments.length) {
        return this._delay;
      }
      this._delay = value;
      this._listen();
      return this;
    };

    /*
     removes the binding
    */


    Binding.prototype.dispose = function() {
      var setter, _i, _len, _ref;

      _ref = this._setters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        setter.dispose();
      }
      this._setters = [];
      if (this._collectionBinding) {
        this._collectionBinding.dispose();
      }
      this._dlisteners();
      return this;
    };

    /*
    */


    Binding.prototype._dlisteners = function() {
      var disposeListener, listener, _i, _j, _len, _len1, _ref, _ref1;

      if (this._listeners) {
        _ref = this._listeners;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          listener = _ref[_i];
          listener.dispose();
        }
      }
      if (this._disposeListeners) {
        _ref1 = this._disposeListeners;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          disposeListener = _ref1[_j];
          disposeListener.dispose();
        }
      }
      this._listeners = [];
      return this._disposeListeners = [];
    };

    /*
    */


    Binding.prototype._listen = function() {
      var disposeListeners, listeners, property, _i, _len, _ref,
        _this = this;

      this._dlisteners();
      listeners = [];
      disposeListeners = [];
      _ref = this._properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        listeners.push(new DeepPropertyWatcher({
          binding: this,
          target: this._from,
          path: property.split("."),
          callback: this.now,
          index: 0,
          delay: this._delay
        }));
      }
      disposeListeners.push(this._from.once("dispose", function() {
        return _this.dispose();
      }));
      this._disposeListeners = disposeListeners;
      return this._listeners = listeners;
    };

    return Binding;

  })();

  /*
  */


  Binding.fromOptions = function(target, options) {
    var binding, t, to, tops, _i, _len, _ref;

    binding = target.bind(options.from || options.property);
    if (type(options.to) === "object") {
      for (to in options.to) {
        tops = options.to[to];
        if (tops.transform || tops.map) {
          binding.map(tops.transform || tops.map);
        }
        if (tops.now) {
          binding.now();
        }
        if (tops.bothWays) {
          binding.bothWays();
        }
        binding.to(to);
      }
    } else {
      options.to = toarray(options.to);
      _ref = options.to;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        tops = typeof t === "object" ? t : {
          property: t
        };
        if (tops.transform || tops.map) {
          bindings.map(tops.transform || tops.map);
        }
        binding.to(tops.property);
      }
    }
    if (options.limit) {
      binding.limit(options.limit);
    }
    if (options.once) {
      binding.once();
    }
    if (options.bothWays) {
      binding.bothWays();
    }
    if (options.now) {
      binding.now();
    }
    return binding;
  };

}).call(this);
