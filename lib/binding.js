// Generated by CoffeeScript 1.4.0
(function() {
  var BindableSetter, Binding, bindableSetter,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  BindableSetter = require("./setters/factory");

  bindableSetter = new BindableSetter();

  /*
   Glues stuff together
  */


  module.exports = Binding = (function() {
    /*
    */

    Binding.prototype.__isBinding = true;

    /*
    */


    function Binding(_from, _property) {
      this._from = _from;
      this._property = _property;
      this._trigger = __bind(this._trigger, this);

      this._limit = -1;
      this._setters = [];
      this._triggerCount = 0;
      this._listen();
    }

    /*
       binds to a target
    */


    Binding.prototype.to = function(target, property) {
      var setter;
      setter = bindableSetter.createSetter(this, target, property);
      if (setter) {
        this._setters.push(setter);
      }
      return this;
    };

    /*
       from property? create a binding going the other way. This is useful for classes. see class-test.js
    */


    Binding.prototype.from = function(from, property) {
      if (arguments.length === 1) {
        property = from;
        from = this._from;
      }
      return from.bind(property).to(this._from, this._property);
    };

    /*
       TODO
    */


    Binding.prototype.transform = function(options) {
      if (!arguments.length) {
        return this._transform;
      }
      if (typeof options === "function") {
        options = {
          from: options,
          to: options
        };
      }
      this._transform = options;
      return this;
    };

    /*
       runs the binding just once
    */


    Binding.prototype.once = function() {
      return this.limit(0);
    };

    /*
       limits the number of times the binding can be called
    */


    Binding.prototype.limit = function(count) {
      this._limit = count;
      return this;
    };

    /*
       returns whether the binding is bound with ways
    */


    Binding.prototype.isBothWays = function() {
      return !!this._boundBothWays;
    };

    /*  
     makes the binding go both ways.
    */


    Binding.prototype.bothWays = function() {
      if (this._boundBothWays) {
        return this;
      }
      this._boundBothWays = true;
      this._callSetterFns("bothWays");
      return this;
    };

    /*
       removes the binding
    */


    Binding.prototype.dispose = function() {
      this._callSetterFns("dispose");
      this._setters = [];
      if (this._listener) {
        this._listener.dispose();
      }
      this._listener = void 0;
      return this;
    };

    /*
       triggers the binding *if* it exists
    */


    Binding.prototype._trigger = function() {
      this._callSetterFns("change", [this._from.get(this._property)]);
      if (~this._limit && ++this._triggerCount > this._limit) {
        this.dispose();
      }
      return this;
    };

    /*
    */


    Binding.prototype._callSetterFns = function(method, args) {
      var setter, _i, _len, _ref, _results;
      _ref = this._setters;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setter = _ref[_i];
        _results.push(setter[method].apply(setter, args || []));
      }
      return _results;
    };

    /*
    */


    Binding.prototype._listen = function() {
      var event, keyParts;
      keyParts = this._property.split(".");
      event = "change:" + (keyParts.shift()) + ".**";
      return this._listener = this._from.on(event, this._trigger);
    };

    return Binding;

  })();

}).call(this);
